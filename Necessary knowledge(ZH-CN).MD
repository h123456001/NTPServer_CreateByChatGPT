# 1. **位运算**

假设一个16进制值位0x23储存在一个byte中 那么其对应的2进制就是00100011
用Go语言进行位运算一步步进行用“<<”运算符从左移动 开始介绍


		以0x23为例：

		（1）将0x23转换为二进制：00100011

		（2）将二进制位运算：

		00100011 << 0 = 00100011

		00100011 << 1 = 01000110

		00100011 << 2 = 10001100

		00100011 << 3 = 00011000

		...

		（3）将运算结果转换为十六进制：

		00100011 = 0x23
		01000110 = 0x46
		10001100 = 0x8C
		00011000 = 0x18
		...

		00100011 << 1 = 01000110 是不是从最右边开始整体向左移动一位那么
		00100011 变为x0100011y  x代表被抛弃的部分 y代表补充0 这么理解对吗？

		是的，你理解的对。当你将0x23左移1位（00100011 << 1），它就变成了0x46（01000110），这就是说，最右边的一位被抛弃，然后补充上一个0，以此类推，每次左移一位，都会有一位被抛弃，然后补充一个0.
		那右移位00100011 >> 1 = 00010001?

		是的，当你将0x23右移1位（00100011 >> 1），它就变成了0x11（00010001），这就是说，最左边的一位被抛弃，然后补充上一个0，以此类推，每次右移一位，都会有一位被抛弃，然后补充一个0.
		按照上述理解我要的到一个8bit中前2个bit的值以00100011为例 应该对该值进行右移6个位也就是00100011>>6 =00000000 也就是说前2个bit的值为0？

		是的，你理解的对。右移6位，即：00100011 >> 6 = 00000000，这就意味着，前两个bit的值为0.
		同理要的到00100011中的00‘10’0011引号标注的算第2位到第三位？

		是的，你要取00100011中的00‘10’0011，那就是将0x23右移2位（00100011 >> 2），它就变成了0x09（00001001），这就是说，右移2位后，就可以得到00‘10’0011，即00001001.我都觉得你说的有错或者理解错误我想的到的是00100011中的00‘10’0011 引号内的部分不是应该先右移4位然后将前2位设置为0吗？

		是的，你的理解是正确的。你要取00100011中的00‘10’0011，那就是先右移4位（00100011 >> 4），它就变成了0x02（00000010），然后在将前两位设置为0，即00‘00’0010，最后得到00‘10’0011，即00000010.那通过go语言该用什么运算符怎么实现呢

		你可以使用Go语言的位操作运算符来实现，比如：

		1. 将0x23右移4位：0x23 >> 4 = 0x02

		2. 将0x02的前两位设置为0：0x02 & 0x3F = 0x02  （0x3F的二进制形式为00111111）

		3. 最后得到00‘10’0011，即00000010.
		2. 将0x02的前两位设置为0：0x02 & 0x3F = 0x02  （0x3F的二进制形式为00111111） 未理解能解释一下吗？

		可以的，这里的&运算符是位运算的“与”运算，它的运算结果是1的条件是两个操作数的每一位都为1，否则结果就是0。所以，0x02 & 0x3F的运算就是让0x02中的前两位都变成0，因为0x3F的二进制形式为00111111，而0x02的二进制形式为00000010，所以，0x02 & 0x3F = 0x02。

		那2用人类理解方式实现将一个数值右移动4位后的到一个新的8bit 二进制值 再将这个值前2位设置为0  仍然以00100011为初始值做例子

		以00100011为例，要将它右移4位，并将前两位设置为0：

		（1）将00100011右移4位：00100011 >> 4 = 00000010

		（2）将00000010的前两位设置为0：00000010 & 00111111 = 00000010

		最后得到00‘10’0011，即00000010. 所以判断一个报文是否标准的NTP报文首先应先判断packet长度
# 2. **NTP协议**
一个标准的NTPv4 数据包payload长度为48个字节，其中包含了以下字段：

```
1. Leap Indicator：2 位，表示NTP服务器时钟异常时的标志，不为零时表示时钟有问题。

2. Version Number：3 位，表示当前NTP数据包的版本号。

3. Mode：3 位，表示NTP数据包的模式，有以下7种：
   0：保留
   1：精确时基
   2：双向交流
   3：客户端
   4：服务器
   5：广播
   6：控制

4. Stratum：8 位，表示NTP服务器的层次，可以取值范围是0-15，0表示未定义，1表示时钟最高层，15表示最低层。

5. Poll Interval：8 位，表示客户端从服务器获取时间间隔，单位是2^n 秒，最小值是4 秒，最大值是17179869184 秒（约20 年）

6. Precision：8 位，表示系统的精度，单位是2^n 秒，最小值是0.5 秒，最大值是128 秒（约2 分钟）

7. Root Delay：32 位，表示服务器和时钟源之间的延迟，单位是秒。

8. Root Dispersion：32 位，表示服务器和时钟源之间的精度，单位是秒。

9. Reference Identifier：32 位，表示时钟源的标识符，可以是IP 地址，也可以是域名。

10. Reference Timestamp：64 位，表示时钟源的时间戳，单位是秒。

11. Originate Timestamp：64 位，表示客户端发出请求时的时间戳，单位是秒。

12. Receive Timestamp：64 位，表示服务器收到请求时的时间戳，单位是秒。

13. Transmit Timestamp：64 位，表示服务器发出响应时的时间戳，单位是秒。 
````